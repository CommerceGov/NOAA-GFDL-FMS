!***********************************************************************
!*                   GNU Lesser General Public License
!*
!* This file is part of the GFDL Flexible Modeling System (FMS).
!*
!* FMS is free software: you can redistribute it and/or modify it under
!* the terms of the GNU Lesser General Public License as published by
!* the Free Software Foundation, either version 3 of the License, or (at
!* your option) any later version.
!*
!* FMS is distributed in the hope that it will be useful, but WITHOUT
!* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
!* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
!* for more details.
!*
!* You should have received a copy of the GNU Lesser General Public
!* License along with FMS.  If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************

!> addtogroup mpp_mod
!> @{

!> @brief Scatter data from one pe to the specified pes.
subroutine MPP_SCATTER_PELIST_2D_(is, ie, js, je, pelist, array_seg, data, is_root_pe, &
   ishift, jshift)
   integer,                           intent(in)    :: is, ie, js, je !< indices of segment array
   integer,   dimension(:),           intent(in)    :: pelist !<PE list of target pes,
                                                              !! must be in monotonic increasing order
   MPP_TYPE_, dimension(is:ie,js:je), intent(inout)    :: array_seg !< 2D array of output data
   MPP_TYPE_, dimension(:,:),         intent(in) :: data !< 2D array of input data
   logical,                           intent(in)    :: is_root_pe !< true if calling from root
   integer,   optional,               intent(in)    :: ishift, jshift !< Offsets of array elements

   MPP_TYPE_ ::  arr3D(size(array_seg,1),size(array_seg,2),1)
   MPP_TYPE_ :: data3D(size(     data,1),size(     data,2),1)
   pointer( aptr,  arr3D )
   pointer( dptr, data3D )
   aptr = LOC(array_seg)
   dptr = LOC(     data)

  call mpp_scatter(is, ie, js, je, 1, pelist, arr3D, data3D, is_root_pe, ishift, jshift)
   return

end subroutine MPP_SCATTER_PELIST_2D_


subroutine MPP_SCATTER_PELIST_3D_(is, ie, js, je, nk, pelist, array_seg, data, is_root_pe, &
  ishift, jshift)
  integer,                                intent(in)    :: is, ie, js, je, nk
  integer,   dimension(:),                intent(in)    :: pelist
  MPP_TYPE_, dimension(is:ie,js:je,1:nk), intent(inout)    :: array_seg
  MPP_TYPE_, dimension(:,:,:),            intent(in) :: data
  logical,                                intent(in)    :: is_root_pe
  integer,   optional,                    intent(in)    :: ishift, jshift

  integer :: i, msgsize, root_pe, root_pe_test
  integer :: i1, j1 !< Starting indices of i and j
  integer :: i2, j2 !< Ending indices of i and j
  integer :: ioff, joff !< Offsets to i and j
  integer :: my_ind(4) !< My starting and ending indices of i and j
  integer :: gind(4,size(pelist)) !< Starting and ending indices of all processes in the group
  integer :: n !< Peset id
  integer :: ierr !< MPI error state
  MPP_TYPE_, allocatable :: send_buf(:) !< Packed data to be scattered; only relevant to the root pe
  MPP_TYPE_, allocatable :: recv_buf(:) !< My chunk of data
  integer :: send_count(size(pelist)) !< Stores message sizes for all processes in the group
  integer :: displ(size(pelist)) !< Displacements for data segments
  integer :: total_msgsize
  integer :: stdout_unit
  integer :: gindx1D(4*size(pelist)) !< Packed version of gind
  integer :: ii, jj, k, m

  if (.not.ANY(mpp_pe().eq.pelist(:))) return

  ! Get peset number
  n = get_peset(pelist)
  if( peset(n)%count.EQ.1 ) return

  do i = 1, mpp_npes()
    if(peset(n)%list(i) == pelist(1)) then
        root_pe = i - 1
        exit
    endif
  enddo

  if (any(peset(n)%list(:) .ne. pelist(:))) call mpp_error(FATAL, "mpp_scatter_mpi: two pelists don't match")

  if( debug )then
    call SYSTEM_CLOCK(tick)
    write( stdout_unit,'(a,i18,a,i6,a,i6)' )&
         'T=',tick, ' PE=', pe, ' MPP_SCATTER begin: from_pe, length=', mpp_pe()
  end if

  if (is_root_pe) then
    if (.not.ANY(pelist(:).eq.root_pe)) call mpp_error(FATAL, "mpp_scatter_mpi: root_pe not a member of pelist")
    if (root_pe .ne. pelist(1)) call mpp_error(FATAL, "mpp_scatter_mpi: root_pe is not the first pe of pelist")
  endif

  send_count = 0
  total_msgsize = 0
  displ = 0
  ioff=0
  joff=0
  if (present(ishift)) ioff=ishift
  if (present(jshift)) joff=jshift

  my_ind(1) = is
  my_ind(2) = ie
  my_ind(3) = js
  my_ind(4) = je

  ! Gather indices from all processes in the group at the root pe
  if (mpp_npes() .gt. 1) call MPI_GATHER(my_ind, 4, MPI_INTEGER4, gindx1D, 4, MPI_INTEGER4, root_pe, peset(n)%id, ierr)
  if (ierr /= MPI_SUCCESS) call mpp_error(FATAL, "mpp_scatter_mpi::MPI_GATHER something is wrong")

  if (any(mpp_pe() .eq. pelist(:))) then
    print "('mpp_scatter_mpi:my_ind ', 'PE ', i4, 4i4)", mpp_pe(), my_ind(1:4)
  end if
  if (mpp_pe() .eq. pelist(1)) then
      !print *, 'mpp_scatter_mpi:pelist', size(pelist), pelist(:)
      !print *, 'mpp_scatter_mpi:list', size(peset(n)%list), peset(n)%list(:)
      !print "('mpp_scatter_mpi:gindx1D ', 'root PE=', i4, 4i4)", root_pe, gindx1D((i-1)*4 + 1:(i-1)*4 + 4)
      print *, 'mpp_scatter_mpi:gindx1D root PE', root_pe, gindx1D(:)
  end if

  ! Compute my message size
  msgsize = (my_ind(2)-my_ind(1)+1) * (my_ind(4)-my_ind(3)+1) * nk
  allocate(recv_buf(msgsize))

  if (is_root_pe) then
    ! Unpack gindx1D(:) to gind(:,:)
    do i = 1, size(pelist)
      gind(1, i) = gindx1D((i-1)*4 + 1)
      gind(2, i) = gindx1D((i-1)*4 + 2)
      gind(3, i) = gindx1D((i-1)*4 + 3)
      gind(4, i) = gindx1D((i-1)*4 + 4)
    end do
    ! Update group indices
    gind(1,:)=gind(1,:)+ioff
    gind(2,:)=gind(2,:)+ioff
    gind(3,:)=gind(3,:)+joff
    gind(4,:)=gind(4,:)+joff
    ! check indices to make sure they are within the range of "data"
    if ((minval(gind).lt.1) .OR. (maxval(gind(1:2,:)).gt.size(data,1)) .OR. (maxval(gind(3:4,:)).gt.size(data,2))) then
      print "('mpp_scatter_mpi:min-max ', 3i6)", minval(gind), maxval(gind(1:2,:)), maxval(gind(3:4,:))
      call mpp_error(FATAL,"mpp_scatter_mpi:: specified indices (with shift) are outside &
        of the range of the receiving array")
    end if
    do i = 1, size(pelist)
      i1 = gind(1,i)
      i2 = gind(2,i)
      j1 = gind(3,i)
      j2 = gind(4,i)
      ! Pack message sizes
      send_count(i) = (i2-i1+1)*(j2-j1+1)*nk
      ! Compute total message size to scatter
      total_msgsize = total_msgsize + send_count(i)
      ! Compute data displacements
      displ(i) = total_msgsize - send_count(i)
      !print "('mpp_scatter_mpi:', 2i6)", displ(i), send_count(i)
    enddo

    ! Allocate send buffer
    allocate(send_buf(total_msgsize))

    total_msgsize = 0
    ! Fill up send_buf with corresponding data chunk for each PE
    do i = 1, size(pelist)
      i1 = gind(1,i)
      i2 = gind(2,i)
      j1 = gind(3,i)
      j2 = gind(4,i)
      total_msgsize = total_msgsize + send_count(i)
      ! Pack data segments
      m = displ(i) + 1
      do k = 1, nk
        do jj = j1, j2
          do ii = i1, i2
            send_buf(m) = data(ii, jj, k)
            m = m + 1
          end do
        end do
      end do
      !send_buf(displ(i)+1:total_msgsize) = reshape(data(i1:i2,j1:j2,1:nk), (/size(data(i1:i2,j1:j2,1:nk))/), &
       ! data(i1:i2,j1:j2,1:nk))
      !print *, 'mpp_scatter_mpi:send_buf', i, send_buf(displ(i)+1:displ(i)+4)
      !print *, 'mpp_scatter_mpi:data', i, data(i1:i2,j1:j2,1:nk)
    enddo
  end if

  ! Scatter data chunks to respective PEs
  if (mpp_npes() .gt. 1) call MPI_SCATTERV(send_buf, send_count, displ, MPI_TYPE_, recv_buf, &
    msgsize, MPI_TYPE_, root_pe, peset(n)%id, ierr)
  if (ierr /= MPI_SUCCESS) call mpp_error(FATAL, "mpp_scatter_mpi::MPI_SCATTERV something is wrong")

  ! Unpack received data
  !if (is_root_pe) then
    !array_seg(is:ie,js:je,1:nk) = reshape(send_buf(1:send_count(1)), (/shape(array_seg(is:ie,js:je,1:nk))/), &
      !send_buf(1:send_count(1)))
  !else
  m = 1
  do k = 1, nk
    do jj = js, je
      do ii = is, ie
        array_seg(ii,jj,k) = recv_buf(m)
        m = m + 1
      end do
    end do
  end do
    !array_seg(is:ie,js:je,1:nk) = reshape(recv_buf, (/shape(array_seg(is:ie,js:je,1:nk))/), recv_buf)
  !end if

  i = 1
  if (i .le. size(pelist)) then
    if (mpp_pe() .eq. pelist(i)) then
      !print *, 'mpp_scatter_mpi:array_seg', array_seg(ie-3:ie,js:js,1:1)
    end if
    if (is_root_pe) then
    !if (any(array_seg(is:ie,js:je,1:nk) .ne. data(gind(1,1):gind(2,1),gind(3,1):gind(4,1),1:nk))) then
      !print *, 'mpp_scatter_mpi: data did not match!'
    !end if
      !print *, 'mpp_scatter_mpi:data', data(gind(2,i)-3:gind(2,i),gind(3,i):gind(3,i),1:1)
    !print *, 'mpp_scatter_mpi:array_seg', array_seg(ie:ie,je:je,1:1)
    end if
  end if

  if( debug .and. (current_clock.NE.0) ) then
    call increment_current_clock( EVENT_SCATTER, msgsize*MPP_TYPE_BYTELEN_ )
  end if

  return
end subroutine MPP_SCATTER_PELIST_3D_
!> @}
