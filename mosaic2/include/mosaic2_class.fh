  !#######################################################################
  !> @brief Get exchange grid information from mosaic xgrid file.
  !> Example usage:
  !!
  !!           call get_mosaic_xgrid(fileobj, nxgrid, i1, j1, i2, j2, area)
  !!
  subroutine GET_MOSAIC_XGRID_(fileobj, i1, j1, i2, j2, area, ibegin, iend, is_class)
    type(FmsNetcdfFile_t), intent(in) :: fileobj !> The file that contains exchange grid information.
    integer,       intent(inout) :: i1(:), j1(:), i2(:), j2(:) !> i and j indices for grids 1 and 2
    class(*),  intent(inout) :: area(:) !> area of the exchange grid. The area is scaled to
    !! represent unit earth area
    integer, optional, intent(in) :: ibegin, iend
    class(*),optional, intent(in) :: is_class

    logical :: is_valid = .true.

    select type(area)
    type is(real(kind=r4_kind))
       call get_mosaic_xgrid(fileobj, i1, j1, i2, j2, area, ibegin, iend)
    type is(real(kind=r8_kind))
       call get_mosaic_xgrid(fileobj, i1, j1, i2, j2, area, ibegin, iend)
    class default
       is_valid = .false.
    end select

    if(.not.is_valid) then
       call mpp_error(FATAL,"get_mosaic_xgrid: invalid type for area")
    end if


  end subroutine GET_MOSAIC_XGRID_

  !###############################################################################
  !> @brief Calculate grid cell area.
  !> Calculate the grid cell area. The purpose of this routine is to make
  !! sure the consistency between model grid area and exchange grid area.
  !> @param lon geographical longitude of grid cell vertices.
  !> @param lat geographical latitude of grid cell vertices.
  !> @param[inout] area grid cell area.
  !> <br>Example usage:
  !!            call calc_mosaic_grid_area(lon, lat, area)
  subroutine CALC_MOSAIC_GRID_AREA_(lon, lat, area, is_class)
    class(*), dimension(:,:), intent(in)    :: lon
    class(*), dimension(:,:), intent(in)    :: lat
    class(*), dimension(:,:), intent(inout) :: area
    logical, intent(in) :: is_class

    logical :: is_valid = .true.


    select type(lon) ; type is(real(kind=r4_kind))
       select type(lat) ; type is(real(kind=r4_kind))
          select type(area) ; type is(real(kind=r4_kind))
             call calc_mosaic_grid_area(lon, lat, area)
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    type is(real(kind=r8_kind))
       select type(lat) ; type is(real(kind=r8_kind))
          select type(area) ; type is(real(kind=r8_kind))
             call calc_mosaic_grid_area(lon, lat, area)
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    class default
       is_valid = .false.
    end select

    if(.not.is_valid) then
       call mpp_error(FATAL,"calc_mosaic_grid_area: invalid type for lat, lon, and/or area")
    end if

  end subroutine CALC_MOSAIC_GRID_AREA_
  !###############################################################################
  !> @brief Calculate grid cell area using great cirlce algorithm
  !> Calculate the grid cell area. The purpose of this routine is to make
  !! sure the consistency between model grid area and exchange grid area.
  !> @param lon geographical longitude of grid cell vertices.
  !> @param lat geographical latitude of grid cell vertices.
  !> @param[inout] area grid cell area.
  !> <br>Example usage:
  !!            call calc_mosaic_grid_great_circle_area(lon, lat, area)
  subroutine CALC_MOSAIC_GRID_GREAT_CIRCLE_AREA_(lon, lat, area, is_class)
    class(*), dimension(:,:), intent(in)    :: lon
    class(*), dimension(:,:), intent(in)    :: lat
    class(*), dimension(:,:), intent(inout) :: area
    logical,  intent(in) :: is_class
    logical :: is_valid=.true.


    select type(lon) ; type is(real(kind=r4_kind))
       select type(lat) ; type is(real(kind=r4_kind))
          select type(area) ; type is(real(kind=r4_kind))
             call calc_mosaic_great_circle_area(lon, lat, area) !< call the r4 interface
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    type is(real(kind=r8_kind))
       select type(lat) ; type is(real(kind=r8_kind))
          select type(area) ; type is(real(kind=r8_kind))
             call calc_mosaic_great_circle_area(lon, lat, area) !< call the r8 interface
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    class default
       is_valid = .false.
    end select

    if(.not.is_valid) then
       call mpp_error(FATAL,"calc_mosaic_grid_great_circle_area: lon, lat, and/or area not valid type")
    end if

  end subroutine CALC_MOSAIC_GRID_GREAT_CIRCLE_AREA_
  !#####################################################################
  !> This function check if a point (lon1,lat1) is inside a polygon (lon2(:), lat2(:))
  !! lon1, lat1, lon2, lat2 are in radians.
  function IS_INSIDE_POLYGON_(lon1, lat1, lon2, lat2, is_class )

    class(*), intent(in) :: lon1, lat1
    class(*), intent(in) :: lon2(:), lat2(:)
    logical,  intent(in) :: is_class

    logical :: IS_INSIDE_POLYGON_
    logical :: is_valid = .true.

    select type(lon1) ; type is(real(kind=r4_kind))
       select type(lat1) ; type is(real(kind=r4_kind))
          select type(lon2) ; type is(real(kind=r4_kind))
             select type(lat2) ; type is(real(kind=r4_kind))
                IS_INSIDE_POLYGON_ = is_inside_polygon(lon1, lat1, lon2, lat2)
             class default
                is_valid = .false.
             end select
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    type is(real(kind=r8_kind))
       select type(lat1) ; type is(real(kind=r8_kind))
          select type(lon2) ; type is(real(kind=r8_kind))
             select type(lat2) ; type is(real(kind=r8_kind))
                IS_INSIDE_POLYGON_ = is_inside_polygon(lon1, lat1, lon2, lat2)
             class default
                is_valid = .false.
             end select
          class default
             is_valid = .false.
          end select
       class default
          is_valid = .false.
       end select

    class default
       is_valid = .false.
    end select

    if(.not.is_valid) then
       call mpp_error(FATAL,"is_inside_polygon: lon1, lat1, lon2, and/or lat2 not valid types")
    end if

  end function IS_INSIDE_POLYGON_
